<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>[Proposal] CHTML</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>
  
  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="66" alt="WICG" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">A partial archive of discourse.wicg.io as of Saturday February 24, 2024.</div>
    <h1 class="topic-title">[Proposal] CHTML</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2020-08-09</div>
          <div class="post_content">
<p>I envision a time when we can natively do what a UI component framework does now. Time has proven that this is beyond the scope of Web Components; we’ve got to develop new language primitives to support bindings and “reactivity”; we’ve got to develop more compositional powers in HTML! This is what I seek to push with CHTML.</p>
<p>CHTML is a (proposed) suite of new DOM features that brings language support for modern UI development paradigms: a component-based architecture, data binding, and reactivity, more composition. This will be helping us bank more on the platform and less on abstractions.</p>
<p>Here is the explainer: <a href="https://github.com/web-native/chtml/blob/master/explainer.md" rel="nofollow noopener">https://github.com/web-native/chtml/blob/master/explainer.md</a></p>
<p>Here is the current polyfill implementation: <a href="https://github.com/web-native/chtml" rel="nofollow noopener">https://github.com/web-native/chtml</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2958_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">bob</div>
          <div class="creation_date">2020-08-10</div>
          <div class="post_content">
<p>I whole-heartedly agree that we should bank more on the platform. Back in the 80s and 90s there was never this problem with developing in proprietary languages. They were stable. You knew where you stood. People got better and more in demand the more they learned the language. Web dev should be, ideally, a place where the more you can do, the more in demand you are. Ideally, the platform should be the <em>main</em> platform for web development. One’s skills should be built on native technology. It should be possible to become a <em>master</em> native programmer, revered by all, spoken about in whispers.</p>
<p>But clearly JavaScript is too low-level for a lot of companies - hence frameworks to aid productivity. There’s no point now, everyone writing their own libraries from native JavaScript and notably it makes no sense from a recruitment agency viewpoint. Companies <em>want</em> to employ coders in specific skills, like React, Vue, Angular, etc. - it’s not like the pioneer days where you can write your own library or learn someone else’s library from scratch. Try getting a job as a native developer and then listen to the reasons companies require that “real” programmers know frameworks. I’m in that situation right now. 49 years of age. Awesome developer. Wrote my own frameworks and libraries. Don’t know any popular frameworks. Having difficulty finding a new job.</p>
<p>Unless you are living under a rock, it is obvious that there needs to be a higher-level common ground for reactive and component functionality, and the browser platform itself should be the place where the magic happens at a high-enough level for people to be able to understand it without needing a CS degree. Ease-of-use is one of the purposes for the internet itself. So it <em>needs</em> to be easy to write UI for the internet. Else we’ll be stuck with static brochure websites forevermore.</p>
<p>The more this elephant in the room can be worked over, the better.</p>
<p>You hit the nail on the head with the platform enhancement. You should get a docs website up with examples, to show how it works in practice. As long as your suggestions work in a 100% backward-compatible way, are as flexible as a framework, and are easier to use than using a framework, then there is a chance. Anything that can be introduced natively that get rid of a framework need is a good thing. Having options for doing things on a web page natively are a good thing. But I would suggest that you get more case studies and examples up there.</p>
<p>I took the other approach to solving this issue of JavaScript being too low-level - extending CSS to be a fully event-driven, modern reactive framework. Sounds a bit weird, I concur. But equally weirdly, it does actually work in practice. It’s like a major extension based on the :hover command. It adds :click, :mouseover, and hundreds of other things. It can be added as-is to CSS as it stands right now, with no changes to any existing CSS specs (AFAIK).</p>
<p>Active CSS has the same scoped variableness of which you speak (great minds, clearly), essentially all the things you mention. is dramatically higher-level than JavaScript, which, let’s face it, is getting a bit beyond your novice web developer when it comes to components and that sort of thing (it takes at least a year to even understand what a shadow DOM is, and another year to stumble upon a valid need for isolated CSS, and then another 100 cups of coffee to grasp the API).</p>
<p><a href="https://activecss.org" rel="nofollow noopener">https://activecss.org</a>. It could be incorporated into the browser in 100% backward-compatible fashion by design. I’m just right now sorting out sequential commands and nested loops to make it look more like a language, and hopefully then can start writing up proper tutorials. I keep getting distracted by missing bits in it and so feel the need to code more to make it complete before telling more people about it. But this post got my attention…</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2020-08-11</div>
          <div class="post_content">
<p>I’m very delighted to see you share my values - banking more on the platform.</p>
<p>You made a valid point in the second paragraph about companies requiring being skilled in a framework. A little note here is that the status quo is based on current limitations and possibilities - which CHTML seeks to change. We’re having to get by with frameworks because we lack native features that help us keep the UI in sync with the state of an application.</p>
<p>With CHTML being a foundational technology, companies can always create higher-level tooling that is specifically adapted to their needs - this time, with less engineering and zero interoperability issues. With or without tooling, the question of building the UI from smaller-sized components and keeping these in sync with an application would have forever been based on a common ground.</p>
<aside class="quote no-group" data-full="true" data-post="2" data-topic="4716" data-username="bob">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/bob/40/2958_2.png" width="20"/> bob:</div>
<blockquote>
<p>But I would suggest that you get more case studies and examples up there.</p>
</blockquote>
</aside>
<p>I am certainly eager to work on more examples, and overall, a clearer documentation than what we have at <a href="https://docs.web-native.dev/chtml" rel="nofollow noopener">https://docs.web-native.dev/chtml</a>. The current proof of concept has been my priority the past many months. I should be back to work on seeing a good amount of interest in CHTML.</p>
<p>I’ll now be heading over to <a href="https://activecss.org" rel="nofollow noopener">https://activecss.org</a> to see what you have up there.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2020-08-17</div>
          <div class="post_content">
<p>So I thought to revise the EXPLAINER to put the discussion points in focus. So, here are the components of the CHTML suite:</p>
<ul>
<li>
<a href="https://github.com/web-native/chtml/blob/master/explainer.md#scoped-html" rel="nofollow noopener">Scoped HTML</a> - Introduces namespaces into HTML to help us structure an HTML document as a hierarchy of <em>scopes</em> and <em>subscopes</em>. (Or components and sub components, to use the “component” terminology.)</li>
<li>
<a href="https://github.com/web-native/chtml/blob/master/explainer.md#scoped-css" rel="nofollow noopener">Scoped CSS</a> - Reproposes scoped stylesheets as a language feature to help us define styling as part of any element.</li>
<li>
<a href="https://github.com/web-native/chtml/blob/master/explainer.md#scoped-js" rel="nofollow noopener">Scoped JS</a> - Introduces scoped scripts into HTML - plain JavaScript that works as a “reactive” data-binding language - to enable us define behaviour as part of any element.</li>
<li>
<a href="https://github.com/web-native/chtml/blob/master/explainer.md#html-partials" rel="nofollow noopener">HTML Partials</a> - Introduces Slots-Based composition into the “open” HTML and a means to define, access, and import reusable HTML snippets.</li>
</ul>
<p>There is also the <a href="https://github.com/web-native/chtml/blob/master/explainer.md#examples" rel="nofollow noopener">examples section</a> that shows how the different parts of the suite fit together and how everything could work with any tool of choice.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2910_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">trusktr</div>
          <div class="creation_date">2020-08-21</div>
          <div class="post_content">
<p>Also it would be great to see examples of how this plays with Custom Elements. How would custom element authors use each of these features? I now CE authors don’t have to use these, and the features can be useful by themselves, but just curious to see what benefit the features may give to CE authors.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2020-09-02</div>
          <div class="post_content">
<p>This is a good question. I do apologise for a delayed response - it happend to be a time of vacation for me.</p>
<p>So, I would say that, while not drastically changing how we author web components, CHTML does offer “shortcuts”, consistency, and a good amount of “neatness” to how we code. These add up to improve the overall developer experience and maintainability of our work.</p>
<p>For example, the <em>namespace</em> API in the <a href="https://github.com/web-native/chtml/blob/master/explainer.md#scoped-html" rel="nofollow noopener">Scoped HTML</a> specs can improve how we name the structural parts of our custom elements and how we access these parts in the JavaScript code. Here is an example of a “collapsible” component:</p>
<p>The markup (based on scoped IDs):</p>
<pre><code class="lang-auto">&lt;my-collapsible namespace&gt;
  &lt;div&gt;
    &lt;div id="control"&gt;&lt;/div&gt;
    &lt;div id="content"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/my-collapsible&gt;
</code></pre>
<p>The JavaScript:</p>
<pre><code class="lang-auto">customElements.define('my-collapsible', class extends HTMLElement {
  constructor() {
    super();
    this.namespace.control.addEventListener('click', () =&gt; {
      // Do something to this.namespace.content
    });
  }
});
</code></pre>
<p>Here, we are now coding against a structural API instead of CSS selectors.</p>
<ul>
<li>
<p>This gives us loose coupling between the JavaScript and the HTML.</p>
</li>
<li>
<p>Using <code>this.namespace</code> instead of <code>this.querySelector()</code> does not only make everything neat, but also self-documenting - giving us the component’s semantics at a glance.</p>
</li>
<li>
<p>Also, with <code>this.namespace</code> being observable, it becomes easy to work with a component whose parts are dynamically added.</p>
</li>
<li>
<p>But the most significant win, arguably, is that we also avoid the specificity wars that using CSS selectors would bring at scale. For example, where this component is nested, we’d hit a terrible problem with a selector like <code>.control</code> at the parent component level:</p>
<pre><code class="lang-auto">&lt;my-collapsible&gt;
  &lt;div&gt;
    &lt;div class="control"&gt;&lt;/div&gt;
    &lt;div class="content"&gt;

      &lt;my-collapsible&gt;
        &lt;div&gt;
          &lt;div class="control"&gt;&lt;/div&gt;
          &lt;div class="content"&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/my-collapsible&gt;

    &lt;/div&gt;
  &lt;/div&gt;
&lt;/my-collapsible&gt;
</code></pre>
</li>
</ul>
<p>Another way CHTML could improve how we author and consume custom elements is in <a href="https://github.com/web-native/chtml/blob/master/explainer.md#html-partials" rel="nofollow noopener">how we define and access <code>&lt;template&gt;</code> elements</a> for use in the shadow DOM. Currently, we query the document by CSS selectors to find a <code>&lt;template&gt;</code> element. But with the <code>document.templates</code> API, that wouldn’t be necessary.</p>
<p>Using the “collapsible” component above:</p>
<p>The HTML (defining the <code>&lt;template&gt;</code> for the component’s Shadow DOM):</p>
<pre><code class="lang-auto">&lt;head&gt;

  &lt;template name="collapsible"&gt;
    &lt;div&gt;
      &lt;div id="control"&gt;&lt;/div&gt;
      &lt;div id="content"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/template&gt;

&lt;/head&gt;
</code></pre>
<p>The JavaScript (accessing the <code>&lt;template&gt;</code> for the component’s Shadow DOM):</p>
<pre><code class="lang-auto">customElements.define('my-collapsible', class extends HTMLElement {
  constructor() {
    super();
    let shadowRoot = this.attachShadow({mode: 'open'});
 
   shadowRoot.append(document.templates.collapsible.innerHTML);
  }
});
</code></pre>
<p>We could even “invert the control” of <code>&lt;template&gt;</code> selection by allowing the <code>&lt;template&gt;</code> element to be <em>decided</em> at component <em>consumption time</em>.</p>
<p>Here, the <code>&lt;template&gt;</code> to use for the Shadow DOM is defined at consumption time:</p>
<pre><code class="lang-auto">&lt;my-collapsible template="collapsible"&gt;&lt;/my-collapsible&gt;
</code></pre>
<p>For this, the JavaScript would use the <code>Element.template</code> API:</p>
<pre><code class="lang-auto">shadowRoot.append(this.template.innerHTML);
</code></pre>
<p>Lastly, CHTML has provided an elegant answer to the all-important subject of data binding and reactivity. Before now, you couldn’t approach this without a “tool” and a template language.</p>
<p>Using <a href="https://github.com/web-native/chtml/blob/master/explainer.md#scoped-js" rel="nofollow noopener">Scoped JS</a>, here is how the collapsible component above could receive and remder data:</p>
<p>The HTML:</p>
<pre><code class="lang-auto">&lt;my-collapsible namespace&gt;

  &lt;div&gt;
    &lt;div id="control"&gt;&lt;/div&gt;
    &lt;div id="content"&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;script scoped&gt;
    this.namespace.content.innerHTML = content;
  &lt;/script&gt;

&lt;/my-collapsible&gt;
</code></pre>
<p>The JavaScript:</p>
<pre><code class="lang-auto">let data = {content: 'Collapsible content'};
document.querySelector('my-collapsible').bind(data);
</code></pre>
<p>Update <code>data.content</code> anytime and the UI is automatically updated.</p>
<p>The benefit of achieving this at the language level is that the modern UI can go without a tool. We shouldn’t really need specialised tools to do this.</p>
<p>Do let me know what you think.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3049_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Essang_Jesse</div>
          <div class="creation_date">2020-09-03</div>
          <div class="post_content">
<p><img alt=":clap:" class="emoji" src="//discourse.wicg.io/images/emoji/twitter/clap.png?v=9" title=":clap:"/> <img alt=":clap:" class="emoji" src="//discourse.wicg.io/images/emoji/twitter/clap.png?v=9" title=":clap:"/> <img alt=":clap:" class="emoji" src="//discourse.wicg.io/images/emoji/twitter/clap.png?v=9" title=":clap:"/> <img alt=":clap:" class="emoji" src="//discourse.wicg.io/images/emoji/twitter/clap.png?v=9" title=":clap:"/>  Very impressive!!!</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2910_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">trusktr</div>
          <div class="creation_date">2020-09-11</div>
          <div class="post_content">
<aside class="quote no-group" data-post="6" data-topic="4716" data-username="ox-harris">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/ox-harris/40/3071_2.png" width="20"/> ox-harris:</div>
<blockquote>
<p>I do apologise for a delayed response</p>
</blockquote>
</aside>
<p>There’s no required timeline for free work. <img alt=":slight_smile:" class="emoji" src="//discourse.wicg.io/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:"/></p>
<p>Those are some really great points that make it clear how custom element benefit. I see how they can be useful. Thanks!</p>
<p>If I understand correctly, Scoped JS could be used <em>inside</em> a custom element implementation like this:</p>
<pre><code class="lang-auto">class NameCard extends HTMLElement {
  _root = null
  _div = null

  connectedCallback() {
    if (!this._root) this._root = this.attachShadow({mode: 'open'})

    this._root.innerHTML = html`
      &lt;div namespace&gt;
        &lt;div&gt;Hello, my name is:&lt;/div&gt;
        &lt;div id="name"&gt;&lt;/div&gt;
        &lt;script scoped&gt;
          this.namespace.name.innerHTML = name;
        &lt;/script&gt;
      &lt;/div&gt;
    `

    this._div = this._root.firstChild
  }

  _values = {}

  attributeChangedCallback(attr, oldVal, newVal) {
    if (this_div &amp;&amp; attr === 'name') {
      this._values.name = newVal ?? 'John Doe'
      this._div.bind(this._values) 
    }
  }
}

customElements.define('name-card', NameCard)
</code></pre>
<p>And the end user consumption:</p>
<pre><code class="lang-auto">&lt;name-card name="Omiron Centis"&gt;&lt;/name-card&gt;
</code></pre>
<p>Are you implying that the code in <code>&lt;script scoped&gt;</code> is a “reactive computation” that gets re-run any time the values of variables (that are dependencies in the script’s code) bound to the containing namespace change?</p>
<p>Is there a declarative way to place the values into the DOM? (f.e. <code>&lt;div&gt;The content: {content}&lt;/div&gt;</code>)?</p>
<p>For that particular use case, here’s how we can do it without ScopedJS, which is a little shorter:</p>
<pre><code class="lang-auto">class NameCard extends HTMLElement {
  _root = null
  _div = null

  connectedCallback() {
    if (!this._root) this._root = this.attachShadow({mode: 'open'})

    this._root.innerHTML = html`
      &lt;div namespace&gt;
        &lt;div&gt;Hello, my name is:&lt;/div&gt;
        &lt;div id="name"&gt;&lt;/div&gt;
      &lt;/div&gt;
    `

    this._div = this._root.firstChild
  }

  attributeChangedCallback(attr, oldVal, newVal) {
    if (this_div &amp;&amp; attr === 'name') {
      this._div.innerHTML = newVal ?? 'John Doe'
    }
  }
}

customElements.define('name-card', NameCard)
</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2020-09-14</div>
          <div class="post_content">
<p>Thank you for this, and for the good thinking that went into it!</p>
<p>So, looking at the use case you gave, I see that another approach would be necessary! Problem with the first code is redundancy. Here, the <code>&lt;name-card&gt;</code> element is observing input data both via <em>attribute-change detection</em> and via <em>Scoped JS’s reactivity</em>. Actually, only one approach would do. Either of the two will be just fine. So, here are different ways I would do data-binding with the <code>&lt;name-card&gt;</code> element using Scoped JS alone, depending on the specific use-case:</p>
<ul>
<li>
<p>If the shadow DOM isn’t really a requirement:</p>
<pre><code class="lang-auto">&lt;name-card namespace&gt;

  &lt;div&gt;Hello, my name is:&lt;/div&gt;
  &lt;div id="name"&gt;&lt;/div&gt;

  &lt;script scoped&gt;
    this.namespace.name.innerHTML = name;
    // If reflecting this value on an attribute is a requirement... say for SEO
    this.setAttribute('name', name);
    // If the component exposed some method... say toggle
    this.toggle(state);
  &lt;/script&gt;

&lt;/name-card&gt;
</code></pre>
<p>Now in the application:</p>
<pre><code class="lang-auto">var data = {name: 'John Doe', state: 'active'};
nameCard.bind(data);
</code></pre>
</li>
<li>
<p>If the shadow DOM is a requirement and much of the work happens inside, you want to send the data in by exposing some method that accepts and uses the data - say a <code>setName()</code> method (more about this method shortly):</p>
<pre><code class="lang-auto">&lt;name-card namespace&gt;

  &lt;script scoped&gt;
    this.setName(name);
    // If the component exposed some other method... say toggle
    this.toggle(state);
  &lt;/script&gt;

&lt;/name-card&gt;
</code></pre>
<p>So, we are practically <em>feeding</em> the component - via its methods - from the reactive script, not the other way around</p>
<p>Now, again, in the application:</p>
<pre><code class="lang-auto">var data = {name: 'John Doe', state: 'active'};
nameCard.bind(data);
</code></pre>
<p>But, lest it seems that it would as well be fine for the application to call the component’s methods directly - <code>nameCard.setName(data.name); nameCard.toggle(data.state)</code> - instead of via the scoped script, we would be missing out on  the reactivity of a scoped script and would have to be manually tracking changes.</p>
<pre><code class="lang-auto">// This is a case where the data is coming from somewhere else
var data = user.data;

// Initial call
nameCard.setName(data.name);
nameCard.toggle(data.state);

// On updates
Observer.observe(data, 'name', update =&gt; {
    nameCard.setName(update.value);
});
Observer.observe(data, 'state', update =&gt; {
    nameCard.toggle(update.value);
});
</code></pre>
<p>This is essentially what a reactive script would do for us when we call <code>nameCard.bind(data)</code>.</p>
<p>In addition, we also get to avoid littering the application layer with much of the implementation details of the presentation layer (having to know the methods, attributes, and the intended behaviour of DOM elements). More on this shortly. For now, at least, we can see that the application code doesn’t have to worry about what happens with the data in the UI.</p>
<p>Now, for the <code>setName()</code> method, here’s how we could implement it:</p>
<pre><code class="lang-auto">class NameCard extends HTMLElement {

    connectedCallback() {
        if (!this._root) this._root = this.attachShadow({mode: 'open'})

        this._root.innerHTML = `
        &lt;div namespace&gt;
          &lt;div&gt;Hello, my name is:&lt;/div&gt;
          &lt;div id="name"&gt;&lt;/div&gt;
        &lt;/div&gt;`;

        this._tree = this._root.firstChild;
    }

    setName(name) {
        this._tree.namespace.name.innerHTML = name;
        // If reflecting this value on an attribute is a requirement... say for SEO
        this.setAttribute('name', name);
    }
}
</code></pre>
</li>
</ul>
<blockquote>
<p>In all, notice that we are <em>reflecting</em> the value of <code>name</code> on the element’s attribute, not obtaining the value via the attribute!</p>
</blockquote>
<p><strong>The Sweet Spot of Scoped JS</strong></p>
<p>Here are a few things about Scoped JS and its <code>.bind()</code> method:</p>
<ol>
<li>
<p><strong>Separation of Concern</strong>: Two layers of code don’t have to know each other to be kept in sync. So, above, our application layer can just be concerned with data manipulation, while the DOM layer with data consumption. They are two separate layers that would be kept separate of each other. This principle becomes broken if the application layer were to be directly manipulating DOM attributes and methods as it would be having to know the implementation details of the DOM.</p>
<p>So there is a down side to the pattern where the communication between the application layer and the DOM layer happens via attributes - <code>element.setAttribute(name)</code> in the application, <code>attributeChangedCallback(attr, oldVal, newVal) {}</code> in the element. But the issue is nothing in a little codebase where the design pattern doesn’t require a strict separation of concern.</p>
</li>
<li>
<p><strong>True Reactivity</strong>: True reactivity lets us work declaratively even with complex data types like nested objects and arrays - an obvious impossibility for attribute-based change-detection mechanisms.</p>
<p>With Scoped JS, we can bind a nested data tree like this:</p>
<pre><code class="lang-auto">var data = {
    user: {name: 'John Doe'},
    state: 'active',
};
nameCard.bind(data);
</code></pre>
<p>then consume it like this:</p>
<pre><code class="lang-auto">&lt;script scoped&gt;
  // We can either consume the "user" branch here...
  this.setName(user.name);
  // Or pass it down to a child component...
  this.namespace.user.bind(user);
  // If the component exposed some other method... say toggle
  this.toggle(state);
&lt;/script&gt;
</code></pre>
<p>and everything will work reactively! For example, the application can update <strong>just the value of <code>data.user.name</code></strong>, and this will trigger <strong>just the <code>this.setName(user.name)</code> statement in the entire script</strong> above. (Or if we actually did pass the <code>user</code> branch to a child component, only the child component responds to the update.)</p>
<p>– <em>Granular DOM updates!</em></p>
</li>
<li>
<p><strong>Simplicity</strong>: Notice how much code is required to create a small behaviour using a custom element. We have to be working with a JavaScript class! We also have to ship the JavaScript code to the browser (often, in real life, involving some tooling - think minifiers). <strong>So… there is this bunch of extra work that goes into provisioning that small <code>attributeChangedCallback(attr, oldVal, newVal) {}</code> block</strong>!</p>
<p>With scoped scripts, there is practically nothing to do upfront, nor afterward! No JavaScript classes, no loading of an external JavaScript file, just behaviours on the fly! Everything starts and ends right within the element markup!</p>
</li>
</ol>
<p><strong>One Last Thing - the Irony of Everything</strong></p>
<blockquote>
<p>Although Scoped JS can drastically improve how we write custom elements, it should actually help us reduce the amount of custom elements we have to write in the first place, as much of the custom elements we write is usually to emulate data-binding or some form of reactive data rending! There is a perfectly reactive data-binding language for that now!</p>
</blockquote>
<p>Okay, your thoughts again…</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3097_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Commentator</div>
          <div class="creation_date">2020-09-22</div>
          <div class="post_content">
<p>I don’t know if CHTML will solve it, but I generally agree we need a decent state-ful GUI markup standard. Perhaps HTML browsers are too burdened already such that we should split web UI into three sub-groups: 1) Media/games/videos, 2) Documents (html may be good enough already), and 3) Productivity: CRUD and data-oriented GUI.</p>
<p>Perhaps one browser could render all three, but the point is to be able to focus on each so that a single standard doesn’t become Swiss Army Knife pasta. It would be 3 different “engines” but a single browser could potentially mix all three, but in different panels.</p>
<p>Perhaps the “GUI browser” could be based off the Tk or Qt tool kits, since those are the most mature open-source kits. The markup language would roughly resemble Microsoft’s XAML language, but be state-ful in that there is interaction.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3097_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Commentator</div>
          <div class="creation_date">2020-09-22</div>
          <div class="post_content">
<p>We might not need gajillion web UI frameworks if browsers natively supported common GUI idioms and behaviors. I agree that if fashionable “eye candy” is your site’s goal, then having choice allows you to stay current on the latest UI fads. But a lot software is for getting work done and doesn’t need the UI widgets to change every 6 months. Intranet and niche business applications have a different need than public facing sites. I’m tired of social media polluting our standards for work software.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3231_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">dy</div>
          <div class="creation_date">2020-11-18</div>
          <div class="post_content">
<p>Nice and well-thought! I came to the same conclusions.
scoped script polyfill (partial) is here <a href="https://gist.github.com/dy/2124c2dfcbdd071f38e866b85436c6c5" rel="noopener nofollow ugc">https://gist.github.com/dy/2124c2dfcbdd071f38e866b85436c6c5</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1765_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">isiahmeadows</div>
          <div class="creation_date">2020-11-23</div>
          <div class="post_content">
<p>With any standard, caution <em>must</em> be exercised, as I’ve seen this XKCD play out IRL far too many times to count. <a href="https://xkcd.com/927/" rel="noopener nofollow ugc">https://xkcd.com/927/</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2020-11-23</div>
          <div class="post_content">
<p>Would it be possible to add details to this - to clarify the problem?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2020-11-23</div>
          <div class="post_content">
<p>Nice and succint, though partial. Really, the case for scoping anything is as clear as the case for modularity.</p>
<p>I am hoping we can soon scope scripts natively: where variables still don’t leak into the global scope. We’ll also have to decide whether to natively have scoped scripts as “reactive” scripts (where statements in the scripts are bound to the data (variables) they reference) or whether to have scoped scripts provide the low-level primitives to do so at a higher level. Meanwhile, the Scoped JS that CHTML proposes has both scoping and reactivity covered, and the polyfill has these implemented.</p>
<p>Personally, the more I explore the possibilities with this idea, the more compelling it feels. I’ll thus be spending some more time to publish our next iteration of the proposal, where we drop a few non-essential and build on key strengths.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2910_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">trusktr</div>
          <div class="creation_date">2021-01-09</div>
          <div class="post_content">
<aside class="quote no-group" data-post="9" data-topic="4716" data-username="ox-harris">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/ox-harris/40/3071_2.png" width="20"/> ox-harris:</div>
<blockquote>
<p>This is essentially what a reactive script would do for us when we call <code>nameCard.bind(data)</code>.</p>
</blockquote>
</aside>
<p>Does <code>nameCard.bind(data)</code> patch the <code>data</code> object with accessors in order to observe the properties?</p>
<aside class="quote no-group" data-post="9" data-topic="4716" data-username="ox-harris">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/ox-harris/40/3071_2.png" width="20"/> ox-harris:</div>
<blockquote>
<p>we also get to avoid littering the application layer with much of the implementation details of the presentation layer</p>
</blockquote>
</aside>
<p>This is definitely a benefit dependency-based reactivity! <img alt=":slight_smile:" class="emoji" src="//discourse.wicg.io/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:"/></p>
<aside class="quote no-group quote-modified" data-post="9" data-topic="4716" data-username="ox-harris">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/ox-harris/40/3071_2.png" width="20"/> ox-harris:</div>
<blockquote>
<blockquote>
<p>In all, notice that we are <em>reflecting</em> the value of <code>name</code> on the element’s attribute, not obtaining the value via the attribute!</p>
</blockquote>
</blockquote>
</aside>
<p>I’m not sure that’s a benefit. I look at attributes as input sources, that a user should set, and the data flows into the component.</p>
<aside class="quote no-group" data-post="9" data-topic="4716" data-username="ox-harris">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/ox-harris/40/3071_2.png" width="20"/> ox-harris:</div>
<blockquote>
<p>Two layers of code don’t have to know each other to be kept in sync.</p>
</blockquote>
</aside>
<p>That is indeed a benefit: the app code (a pure-JS file) just binds the data. In another (HTML) file, the HTML author wires up the method calls. So now we have two different source codes, where the logic business logic just needs to know what the shape of the object to bind should be, based on what the HTML author says, and that object shape may not correlate to the shape of the elements that the HTML author used.</p>
<aside class="quote no-group" data-post="9" data-topic="4716" data-username="ox-harris">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/ox-harris/40/3071_2.png" width="20"/> ox-harris:</div>
<blockquote>
<p>True Reactivity</p>
</blockquote>
</aside>
<p>Yep, love dep-based reactivity! I like dependency-tracking reactivity where the dependencies are detected based on which variable a code expression uses.</p>
<aside class="quote no-group quote-modified" data-post="9" data-topic="4716" data-username="ox-harris">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/ox-harris/40/3071_2.png" width="20"/> ox-harris:</div>
<blockquote>
<blockquote>
<p>There is a perfectly reactive data-binding language for that now!</p>
</blockquote>
</blockquote>
</aside>
<p>I agree, this can be beneficial for quick reactivity without the need for custom elements. And custom elements can additionally be used to further ship re-usable DOM.</p>
<p>It would be great if this included a template syntax. I think that could make things simpler. For example:</p>
<p>Business logic:</p>
<pre><code class="lang-auto">const data = {name: "John Doe"}
el.bind(data)
</code></pre>
<p>HTML code:</p>
<pre><code class="lang-auto">&lt;div namespace&gt;
  Hi my name is: {name}
&lt;/div&gt;
</code></pre>
<p>and then the <code>script</code> is not needed at all. That would really simplify things for people who learn first with HTML and CSS before JavaScript. I can imagine it being difficult to wrap one’s mind around the script parts.</p>
<p>If we could have both simple templating (no script tags) and a way to include HTML files in other HTML files, we’d be in a good shape for HTML devs to get work done without any JavaScript.</p>
<p>At the moment I’m guiding someone learn HTML/CSS. The very first problem they have is duplicating HTML everywhere. Especially for different pages. The web has no tool-less way to re-use HTML.</p>
<p>Imagine this:</p>
<pre><code class="lang-auto">&lt;!-- namecard.html --&gt;
&lt;div&gt;
  &lt;span&gt;My name is &lt;b&gt;{fullName}&lt;/b&gt;.&lt;/span&gt;
&lt;/div&gt;
&lt;style&gt;...scoped css perhaps...&lt;/style&gt;
</code></pre>
<pre><code class="lang-auto">&lt;!-- app.html --&gt;
&lt;h1&gt;Awesome site!&lt;/h1&gt;
&lt;include src="./namecard.html" name="Poe" /&gt;
</code></pre>
<p>If things were that simple, HTML specialists would have such a good time re-using HTML without writing JavaScript.</p>
<p>Something like your idea would then add an additional layer when script is needed:</p>
<pre><code class="lang-auto">&lt;!-- namecard.html --&gt;
&lt;div namespace&gt;
  &lt;span&gt;My name is &lt;b&gt;{this.fullName}&lt;/b&gt;.&lt;/span&gt;
  &lt;script scoped&gt;
    this.fullName = first + last
  &lt;/script&gt;
&lt;/div&gt;
&lt;style&gt;...scoped css perhaps...&lt;/style&gt;
</code></pre>
<pre><code class="lang-auto">&lt;!-- app.html --&gt;
&lt;h1&gt;Awesome site!&lt;/h1&gt;
&lt;include src="./namecard.html" first="Poe" last="Jacobs" /&gt;
</code></pre>
<p>Or perhaps <code>&lt;include&gt;</code> has its own namespace (or there’s a lack of any namespace, however the vendor implementation wants to look at it, and:</p>
<pre><code class="lang-auto">&lt;!-- namecard.html --&gt;
&lt;div&gt;
  &lt;span&gt;My name is &lt;b&gt;{this.fullName}&lt;/b&gt;.&lt;/span&gt;
  &lt;script scoped&gt;
    // maybe this is an object for this file when it is `&lt;include&gt;`ed, or something.
    this.fullName = first + last
  &lt;/script&gt;
&lt;/div&gt;
&lt;style&gt;...scoped css perhaps...&lt;/style&gt;
</code></pre>
<pre><code class="lang-auto">&lt;!-- app.html --&gt;
&lt;h1&gt;Awesome site!&lt;/h1&gt;
&lt;include src="./namecard.html" first="Poe" last="Jacobs" /&gt;
</code></pre>
<p>Reactivity is nice, but the main thing missing is re-usability in the first place (except with JavaScript which an HTML developer can’t avoid).</p>
<p>I think both ES Module and an HTML-imports-like thing should both exist. I think HTML imports should be super simple, just as the word <code>include</code> hints at.</p>
<p>I strayed off topic, but I couldn’t help but think: if I’m already writing custom elements (because I <em>need</em> code re-use), then I am totally fine with a <code>class</code>-based system housing my reactivity logic. I am going to write custom elements <em>anyway</em> because I <em>need</em> to re-use HTML (or JSX, or similar) to avoid pasting duplicate HTML everywhere. Because I’m already using Custom Elements for this purpose, the <code>&lt;script scoped&gt;</code> doesn’t add much for me (it’s reactivity without the re-usability). Let me know if I overlooked something.</p>
<p>Just to share, my <a href="https://github.com/lume/element" rel="noopener nofollow ugc">Custom Element</a> system looks like this:</p>
<pre><code class="lang-auto">import {Element, reactive, attribute} from '@lume/element'

@reactive
class NameCard extends Element {
  @reactive @attribute name = "Wolverine"
  span = null

  // This runs once (it's a reactive computation), not over and over (no vdom).
  template = () =&gt; {
    const div = &lt;div&gt;
      &lt;span ref={this.span}&gt;Hi, my name is: {this.name}&lt;/span&gt;
    &lt;/div&gt;
    jQuery.somePlugin(div)
    console.log(div instanceof HTMLDivElement) // true, only runs once.
    return div
  }

  connectedCallback() {
    super.connectedCallback()
    jQuery.otherPlugin(this.span)
    console.log(this.span instanceof HTMLSpanElement) // true
  }
}
</code></pre>
<p>I wrote it that way so some features of it are apparent. But it is cleaner without the references or effects within <code>template</code>:</p>
<pre><code class="lang-auto">import {Element, reactive, attribute} from '@lume/element'

@reactive
class NameCard extends Element {
  @reactive @attribute name = "Wolverine"

  // This runs once (it's a reactive computation), not over and over (no vdom).
  template = () =&gt; (
    &lt;div ref={this.div}&gt;
      &lt;span ref={this.span}&gt;Hi, my name is: {this.name}&lt;/span&gt;
    &lt;/div&gt;
  )

  connectedCallback() {
    super.connectedCallback()
    jQuery.somePlugin(div)
    console.log(this.div instanceof HTMLDivElement) // true
    jQuery.otherPlugin(this.span)
    console.log(this.span instanceof HTMLSpanElement) // true
  }
}
</code></pre>
<p>The template stuff is usable without custom elements. For example, and with an <code>html</code> template tag instead of JSX, and no build tools:</p>
<pre><code class="lang-auto">import {html, variable} from '@lume/element'

const name = variable('Wolverine')
let span
const p = document.createElement('p')
p.innerText = 'This is a paragraph.'

const div = html`
  &lt;div&gt;
    &lt;span ref=${s =&gt; span = s}&gt;${name}&lt;/span&gt;
    ${p}
  &lt;/div&gt;
`

jQuery.somePlugin(div)
jQuery.otherPlugin(span)

document.body.append(div)

// later...
name('Spiderman') // The DOM is updated

// later we're done...
div.remove()
</code></pre>
<p>What I’m trying to show is, because I need re-usability, I can already use JavaScript to do everything I need, so the <code>script/namespace</code> idea doesn’t add much for me because I already need to write JS files to re-use pieces of UI, and the declarative nature of the reactivity that I currently have is just what I like, whereas with <code>&lt;script scoped&gt;</code> I still have to write imperative JS code (even if its in HTML) in order to send data where it needs to go.</p>
<p>I think a declarative reactive solution would be great if it also provided HTML developers re-usability so that they aren’t required to know JavaScript to in order to re-use pieces of their UI. Then a JavaScript author (one who may or may not write Custom Elements), can provided the data for the HTML author’s UIs. A Custom Element author could even <code>include</code> an HTML author’s HTML files into a larger Custom Element that the HTML author could then re-use in another file too.</p>
<p>EDIT: I made a topic just for <a href="https://discourse.wicg.io/t/non-javascript-html-authors-suffer-from-code-duplication/5098">HTML re-usability</a>.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2021-01-25</div>
          <div class="post_content">
<blockquote>
<p>Does nameCard.bind(data) patch the data object with accessors in order to observe the properties?</p>
</blockquote>
<p>No. Object accessors aren’t used. Proxies aren’t used either. The <code>bind()</code> method internally uses the <a href="https://github.com/webqit/observer" rel="noopener nofollow ugc">Observer API</a>. So, properties set or deleted using the Observer’s <code>set()</code> and <code>deleteProperty()</code> methods are observed on the fly. All other possibilites are documented with the Observer API.</p>
<blockquote>
<p>I’m not sure that’s a benefit. I look at attributes as input sources, that a user should set, and the data flows into the component.</p>
</blockquote>
<p>Well, it turns out that only string-type data can flow in. <code>&lt;name-card fname="John" lname="Doe"&gt;&lt;/name-card&gt;</code> What about data structures like objects and arrays? Flatten them into a thousand attribute names? And what about nested data structures? These are some cases where being able to pass in an (observable) object is useful. While not invalidating the other attribute-based pattern.</p>
<aside class="quote no-group" data-full="true" data-post="16" data-topic="4716" data-username="trusktr">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/trusktr/40/2910_2.png" width="20"/> trusktr:</div>
<blockquote>
<p>It would be great if this included a template syntax. I think that could make things simpler. For example:</p>
<p>Business logic:</p>
<pre><code class="lang-auto">const data = {name: "John Doe"}
el.bind(data)
</code></pre>
<p>HTML code:</p>
<pre><code class="lang-auto">&lt;div namespace&gt;
  Hi my name is: {name}
&lt;/div&gt;
</code></pre>
<p>and then the <code>script</code> is not needed at all. That would really simplify things for people who learn first with HTML and CSS before JavaScript. I can imagine it being difficult to wrap one’s mind around the script parts.</p>
</blockquote>
</aside>
<p>This would be a good idea. Certainly just maps JS values to HTML slots. But there are concerns I’ve battled with:</p>
<ul>
<li>
<p>The <code>{}</code> curly braces, in any combination, are nothing but text characters in HTML. Repurposing them for a Domain-Specific Language would be very odd. One option could be hinting the HTML parser of some template variables ahead:</p>
<pre><code class="lang-auto">  &lt;div vars="name, somethingelse"&gt;
    Hi my name is: {name}. This is {somethingelse}.
  &lt;/div&gt;
</code></pre>
<p><em>This was just some thoughts.</em></p>
</li>
<li>
<p>We may just realize that a simple way to map JS values to slots in HTML isn’t enough. Sometimes we want some little power at the HTML level to transform the value to render.</p>
<pre><code class="lang-auto">  &lt;div vars="name, somethingelse"&gt;
    Hi my name is: {name.toUpperCase()}. This is {somethingelse}.
  &lt;/div&gt;
</code></pre>
<p>A lot of templating systems out there have to reinvent a new language for things like this. And we end up in more complexity than where we’re coming from. A new language to learn and debug.</p>
</li>
</ul>
<p>These issues are already overcome by a Scoped Script. And a simplistic mapping pattern is also possible:</p>
<pre><code class="lang-auto">&lt;div namespace&gt;
    Hi my name is: &lt;span id="name"&gt;name&lt;/span&gt;
    &lt;script type="scoped"&gt;
        this.namespace.name = value; // value.toUpperCase()
    &lt;/script&gt;
&lt;/div&gt;
</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2021-01-26</div>
          <div class="post_content">
<aside class="quote no-group" data-post="16" data-topic="4716" data-username="trusktr">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/trusktr/40/2910_2.png" width="20"/> trusktr:</div>
<blockquote>
<p>If we could have both simple templating (no script tags) and a way to include HTML files in other HTML files, we’d be in a good shape for HTML devs to get work done without any JavaScript.</p>
<p>At the moment I’m guiding someone learn HTML/CSS. The very first problem they have is duplicating HTML everywhere. Especially for different pages. The web has no tool-less way to re-use HTML.</p>
<p>Imagine this:</p>
<pre><code class="lang-auto">&lt;!-- namecard.html --&gt;
&lt;div&gt;
  &lt;span&gt;My name is &lt;b&gt;{fullName}&lt;/b&gt;.&lt;/span&gt;
&lt;/div&gt;
&lt;style&gt;...scoped css perhaps...&lt;/style&gt;
</code></pre>
<pre><code class="lang-auto">&lt;!-- app.html --&gt;
&lt;h1&gt;Awesome site!&lt;/h1&gt;
&lt;include src="./namecard.html" name="Poe" /&gt;
</code></pre>
<p>If things were that simple, HTML specialists would have such a good time re-using HTML without writing JavaScript.</p>
</blockquote>
</aside>
<p>This is something I want to talk about as this has been the whole point of CHTML:</p>
<ul>
<li>
<strong>Being able to reuse HTML without having to involve JavaScript</strong> (entirely covered in <a href="https://github.com/web-native/chtml/blob/master/explainer.md#html-partials" rel="noopener nofollow ugc">the HTML Partials part</a> of CHTML)</li>
<li>
<strong>While, at the same time, having everything work reactively, as barely as without JavaScript classes or JS files</strong>, but with support for those when you want to still have them (the whole point of <a href="https://github.com/web-native/chtml/blob/master/explainer.md#scoped-js" rel="noopener nofollow ugc">the Scoped JS part</a> of CHTML)</li>
</ul>
<p>You’ll quickly realize that if we had one without the other, the entire essence of trying to keep JavaScript where it belongs is missed! We would still be stranded! That is why I am proposing these features <strong>together as one suite - CHTML</strong>, instead of as standalone ideas. <strong>This cannot be over-emphasized: if we developed these ideas separately of each other, we would end up missing that one theme they share.</strong></p>
<p>Now, once you begin threading the path away from an all-JS approach, you’ll quickly realize just how <em>flat and non-modular</em> HTML is by itself. You’d need JavaScript again even before you’re able to do something practical with the first two features - reusability, reactivity. Modularity becomes the next pain! And this is the next thing covered in the suite:</p>
<ul>
<li>
<strong>The ability to keep IDs scoped to a context other than the global scope</strong> (<a href="https://github.com/web-native/chtml/blob/master/explainer.md#scoped-html" rel="noopener nofollow ugc">the Scoped HTML part</a> of CHTML.)</li>
</ul>
<p>This gives us at least three things to need together: <strong>reusability</strong>, <strong>reactivity</strong>, and <strong>modularity</strong>. And from my months of testing these assumptions, the results are that if we had these, the entire problem you highlighted would be delightfully addressed. We wouldn’t require JavaScript components <strong>just</strong> to reuse HTML or to make the UI modular. The guy at the HTML end can create markup independent of an application layer and still be able to author reactive UIs.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3777_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">ox-harris</div>
          <div class="creation_date">2021-01-26</div>
          <div class="post_content">
<p>One question about CHTML I’d like to answer is <em>why a new proposal when we’ve had existing efforts in some of the areas covered in CHTML</em>. The answer lies in these two factors: scope, timing, in the light of CHTML’s theme: the ability to create reusable, reactive, and modular HTML at HTML level.</p>
<ol>
<li>
<p><strong>Scope</strong>: there is really no proposal with a scope as complete as CHTML’s. And it is difficult to <em>make complete sense</em> of individual flying ideas, let alone <em>have them work as one</em> when they eventually do ship. For example, what real benefit would we have if the platform shipped <em>just one</em> of reusability, reactivity, and modularity? Having developed the first independently of the others, how would we get it to naturally support those later on?</p>
</li>
<li>
<p><strong>Timing</strong>: some existing proposals were made at a time <em>we were yet to realize</em> all what would be involved to achieve the said goal. This explains the first.</p>
</li>
</ol>
<p>CHTML’s theme is what underpins  some of the existing proposals. But the limited individual scopes have made the directions different from CHTML’s.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">mkay581</div>
          <div class="creation_date">2021-01-26</div>
          <div class="post_content">
<p>I like this discussion but I’m confused. Everyone keeps referencing CHTML in the <a href="https://github.com/web-native/chtml" rel="noopener nofollow ugc">web-native/chtml</a> repository but it says it’s been moved to <a href="https://github.com/webqit/oohtml" rel="noopener nofollow ugc">WebQit/oohtml</a>, which is named OOHTML. Which is it?</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>
