<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>Additional use cases for InputDeviceCapabilities</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>
  
  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="66" alt="WICG" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">A partial archive of discourse.wicg.io as of Thursday February 08, 2024.</div>
    <h1 class="topic-title">Additional use cases for InputDeviceCapabilities</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/503_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">RickByers</div>
          <div class="creation_date">2015-10-08</div>
          <div class="post_content">
<p>In <a href="//discourse.wicg.io/t/inputdevice-api-for-identifying-mouse-events-derived-from-touch/972">this thread</a> I discussed a simple extension to <code>UIEvent</code> to provide access to an <a href="http://rbyers.github.io/InputDevice/#dom-inputdevicecapabilities" rel="nofollow noopener"><code>InputDeviceCapabilities</code></a> object describing properties of the underlying input device.  We <a href="https://www.chromestatus.com/features/5681847971348480" rel="nofollow noopener">shipped this API in Chrome 47</a> but it was really focused on solving one very specific use cases.</p>
<p>I’ve heard lots of other example of information developer want here, but it’s not clear to me what the key concrete use cases are, and what’s of most value to web developers?  Maybe we can brainstorm here a little?</p>
<p>Here’s some of the main ideas I’ve heard:</p>
<ol>
<li>
<p>When implementing custom focus rings (rather than relying on the browser’s built-in behavior), deciding whether a <code>focus</code> event is due to a device (like a keyboard) that needs focus rings.  Related to (perhaps the underlying primitive explaining) <a href="//discourse.wicg.io/t/exposing-a-users-input-modality/1067">this discussion</a>.</p>
</li>
<li>
<p>Detecting whether a device sending ‘wheel’ events can support full 2D drag (and possibly zoom).  Eg. in Google Maps, wheel events normally zoom.  This makes the most sense for a physical mouse wheel.  But with a high-precision touchpad that supports full 2d-panning and pinch-zoom (via ctrl-wheel events), it would be better to pan the map on most <code>wheel</code> events (like <a href="http://output.jsbin.com/yukebe" rel="nofollow noopener">this demo page</a>).</p>
</li>
<li>
<p>Detecting whether the device introduces a significant delay before firing <code>click</code> events.  Eg. libraries like FastClick try to guess if they should synthesize their own <code>click</code> from TouchEvents.  But in many scenarios/browsers this is unnecessary.</p>
</li>
<li>
<p>Determining whether the device sends mouse events (eg. <code>mousemove</code>, <code>mouseenter</code> and <code>mouseleave</code> when hovering).  For example this is true for stylus and mouse devices on Android, but not for touch screen devices.</p>
</li>
<li>
<p>Are <code>wheel</code> events generated by the device precise and/or high-frequency?  Eg. if the user is using a physical mouse wheel (that moves in ticks, each sending a single <code>wheel</code> event), then perhaps the page should animate positions between each event.  But if <code>wheel</code> events are generated with precise delta values at a high rate, then it shouldn’t.</p>
</li>
<li>
<p>Determine whether an input device is implemented by currently taking up space on the screen.  Eg. to tell if an on-screen keyboard is currently displayed so that the UI can be made more compact.</p>
</li>
</ol>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1818_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">briankardell</div>
          <div class="creation_date">2015-10-08</div>
          <div class="post_content">
<aside class="quote" data-post="1" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/rickbyers/40/503_1.png" width="20"/> RickByers:</div>
<blockquote>
<p>When implementing custom focus rings (rather than relying on the browser’s built-in behavior), deciding whether a focus event is due to a device (like a keyboard) that needs focus rings.  Related to (perhaps the underlying primitive explaining) this discussion.</p>
</blockquote>
</aside>
<p>We discussed this a little on IRC in Sydney - I like this idea a lot and it might indeed provide an answer that is enough for solving event handing on the focus ring cases mentioned in the other thread just as well (maybe better) than a new event, but it’s not a capability.  Would you change the name or shoe it in somehow?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/503_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">RickByers</div>
          <div class="creation_date">2015-10-09</div>
          <div class="post_content">
<aside class="quote" data-post="2" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/briankardell/40/70_1.png" width="20"/> briankardell:</div>
<blockquote>
<p>We discussed this a little on IRC in Sydney - I like this idea a lot and it might indeed provide an answer that is enough for solving event handing on the focus ring cases mentioned in the other thread just as well (maybe better) than a new event, but it’s not a capability.  Would you change the name or shoe it in somehow?</p>
</blockquote>
</aside>
<p>Yeah that’s a good point.  The point of using the name ‘capability’ (I think - it was a late-breaking change, I orignally just called it <code>InputDevice</code> and <code>sourceDevice</code>) was to force us to think in terms that will stand the test of time - how the device is used, not what it is.</p>
<p>So maybe the capability that matters here is something like <code>directTargeting</code>.  A mouse can directly target elements, but a keyboard requires indirect navigation with the help of focus rings to indicate the current target.  WDYT?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/715_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">aboxhall</div>
          <div class="creation_date">2015-10-15</div>
          <div class="post_content">
<aside class="quote" data-post="3" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/rickbyers/40/503_1.png" width="20"/> RickByers:</div>
<blockquote>
<p>So maybe the capability that matters here is something like directTargeting.  A mouse can directly target elements, but a keyboard requires indirect navigation with the help of focus rings to indicate the current target.  WDYT?</p>
</blockquote>
</aside>
<p>I definitely like this idea, though I’m not clear on how it would be exposed in the event.</p>
<p>One wrinkle is that at least focus events can be indirectly triggered by user interactions, like a button press which triggers a menu or modal dialog. We’d need to either be clever about deducing when this was the case (and, as we discovered, it won’t always be in the same control flow) or (more likely?) allow authors to specify this when explicitly moving focus.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/503_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">RickByers</div>
          <div class="creation_date">2015-10-20</div>
          <div class="post_content">
<aside class="quote" data-post="4" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/aboxhall/40/715_1.png" width="20"/> aboxhall:</div>
<blockquote>
<p>I definitely like this idea, though I’m not clear on how it would be exposed in the event.</p>
</blockquote>
</aside>
<p>Every <code>UIEvent</code> would have a <code>sourceCapabilities.directTargeting</code> boolean property (true if the event was triggered via a pointer, false if triggered via a keyboard / DPAD).</p>
<aside class="quote" data-post="4" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/aboxhall/40/715_1.png" width="20"/> aboxhall:</div>
<blockquote>
<p>One wrinkle is that at least focus events can be indirectly triggered by user interactions, like a button press which triggers a menu or modal dialog. We’d need to either be clever about deducing when this was the case (and, as we discovered, it won’t always be in the same control flow) or (more likely?) allow authors to specify this when explicitly moving focus.</p>
</blockquote>
</aside>
<p>Interesting.  When dispatching a <code>UIEvent</code> directly from JavaScript we allow authors to supply their own <code>InputDeviceCapabilities</code> instance.  It seems reasonable to me that <code>Element.focus()</code> should optionally take an <code>InputDeviceCapabilities</code> too.  At it’s most primitive this feature is really just plumbing passing some extra state around to help developers reason about causality.  We had to do a bunch of plumbing internally to pass around source information for focus, so extending that out to <code>focus()</code> seems natural to me.  Not sure how hard of a sell that will be though.</p>
<p>Oh and by the way, in case it’s not clear, I’m not in any way opposed to your <a href="//discourse.wicg.io/t/exposing-a-users-input-modality/1067/26">media-query based proposal</a> either, I just don’t understand the situation well enough yet to have an opinion.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1818_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">briankardell</div>
          <div class="creation_date">2015-10-21</div>
          <div class="post_content">
<aside class="quote" data-post="5" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/rickbyers/40/503_1.png" width="20"/> RickByers:</div>
<blockquote>
<p>Oh and by the way, in case it’s not clear, I’m not in any way opposed to your media-query based proposal either, I just don’t understand the situation well enough yet to have an opinion.</p>
</blockquote>
</aside>
<p>After discussing with the WG there was kind of a split.  Some implementers were worried because a MQ causes whole sheets to be added or removed requiring a lot of extra work and MQs are pretty carefully crafted to make sure they don’t happen very often - for example, a user might resize like crazy but we only pass a breakpoint once.  Since focus is a thing that happens with great regularity (especially when using sequential navigation).  There are some ways around this, but they’re technically complicated and therefore unlikely to convince people to do…</p>
<p>Given this, and known use cases it was thought that a pseudo-class is nearly as good and Mozilla has had an experimental implementation of almost precisely this for a while so it’s possible to slot it into existing selectors specs and move pretty quickly.  The major concern this leaves me with is the DOM side - letting script participate intelligently without re-inventing it all.  Personally I don’t relish the idea of adding another event, figuring out the lifecycle, going through another process, etc – so when I saw this I thought – something like this feels like a simpler solution to that end of it.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">skibulk</div>
          <div class="creation_date">2015-10-28</div>
          <div class="post_content">
<p>It would be useful to read advanced Wacom stylus input: pressure, tilt, and rotation. Pointer Events will be implemented in Chrome eventually, but the specification only supports pressure, tilt, and is far-future. All 3 controls are useful while simulating traditional media in drawing and painting applications.</p>
<p>It could be useful to access 3D Navigator device input. These can be used to navigate game environments or rotate 3d models.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/503_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">RickByers</div>
          <div class="creation_date">2015-10-28</div>
          <div class="post_content">
<aside class="quote" data-post="7" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/letter_avatar_proxy/v2/letter/s/49beb7/40.png" width="20"/> skibulk:</div>
<blockquote>
<p>It would be useful to read advanced Wacom stylus input: pressure, tilt, and rotation. Pointer Events will be implemented in Chrome eventually, but the specification only supports pressure, tilt, and is far-future. All 3 controls are useful while simulating traditional media in drawing and painting applications.</p>
</blockquote>
</aside>
<p>I agree having this data would be useful, but unfortunately <code>InputDeviceCapabilities</code> isn’t the right place for it.  <code>InputDeviceCapabilities</code> are about properties of the device that don’t change while it’s being used.  We might want to consider things like <code>supportsPressure</code> thought.</p>
<p>The right way to get this input data exposed to JS is via one of the existing event APIs.  For getting rotation into pointer events I’d encourage you to file an issue <a href="https://github.com/w3c/pointerevents/issues" rel="nofollow noopener">here</a>, perhaps pointing at an existing use case for rotation.  We’re hoping to ship pointer events in Chrome within the next year, so in terms of web standards that’s not THAT “far future”.  But I’d also personally support adding stylus properties to other event APIs (<code>TouchEvent</code> on mobile, <code>MouseEvent</code> on desktop).  But this is very contentious (with most people arguing you should just wait for pointer events).  If you feel strongly, feel free to propose that to the relevant standards list.</p>
<aside class="quote" data-post="7" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/letter_avatar_proxy/v2/letter/s/49beb7/40.png" width="20"/> skibulk:</div>
<blockquote>
<p>It could be useful to access 3D Navigator device input. These can be used to navigate game environments or rotate 3d models.</p>
</blockquote>
</aside>
<p>Again that’s really about a richer input API.  Whether or not a device is <em>capable</em> of doing 3d navigation is something that could make sense for <code>InputDeviceCapabilities</code>.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1013_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">IvanSanchez</div>
          <div class="creation_date">2016-06-03</div>
          <div class="post_content">
<p>Hi, Iván from <a href="https://github.com/Leaflet/Leaflet" rel="nofollow noopener">Leaflet</a> here.</p>
<p>We’ve been struggling with <a href="https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent" rel="nofollow noopener"><code>MouseWheel</code></a> events for the past few months, trying to detect the number of discrete ticks performed when a user uses the scrollwheel. As the <code>MouseWheel</code> event only reports scrolled pixels, but this amount varies wildly between browsers.</p>
<p>Let me quote from <a href="https://github.com/Leaflet/Leaflet/issues/4538" rel="nofollow noopener">bug #4538 in Leaflet</a>:</p>
<blockquote>
<p>Chrome in Win7 indeed scrolls 100 pixels per wheel click, whereas in Linux it scrolls 50.</p>
</blockquote>
<p>With the same hardware, Edge will scroll anything from 115px to 125px, firefox will scroll 48px, and Safari will scroll ~4px.</p>
<p>So exposing things like MacOSX’s <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSEvent_Class/index.html#//apple_ref/occ/instp/NSEvent/hasPreciseScrollingDeltas" rel="nofollow noopener"><code>hasPreciseScrollingDeltas</code></a> is a very interesting use case. Furthermore, this is the perfect place to report the amount of pixels the browser is expected to scroll per <em>discrete</em> (or “low-res”) scroll tick, and end browser-detection kludges.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/503_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">RickByers</div>
          <div class="creation_date">2016-06-03</div>
          <div class="post_content">
<blockquote>
<p>Let me quote from bug <span class="hashtag">#4538</span> in Leaflet2:</p>
</blockquote>
<blockquote>
<blockquote>
<p>Chrome in Win7 indeed scrolls 100 pixels per wheel click, whereas in Linux it scrolls 50.</p>
</blockquote>
</blockquote>
<blockquote>
<p>So exposing things like MacOSX’s hasPreciseScrollingDeltas is a very interesting use case. Furthermore, this is the perfect place to report the amount of pixels the browser is expected to scroll per discrete (or “low-res”) scroll tick, and end browser-detection kludges.</p>
</blockquote>
<p>Thanks for the scenario!  If I understand correctly, you really want different behavior for discrete-wheel devices (one zoom level per tick) from devices with some sort of continuous zoom.  I agree this scenario is important.  There’s been some recent discussion of this on the Chrome team in the context of just <a href="https://github.com/w3c/uievents/issues/17" rel="nofollow noopener">adding</a> <code>ticks</code> to <code>WheelEvent</code>.  Rather than try to predict delta-per-tick, would it be better to expose <code>ticks</code> along with a <code>hasPreciseScrollingDeltas</code> bit on <code>InputDeviceCapabilities</code>?</p>
<p>I think the biggest issue here is that it’s not clear to us to what extent this API is implementable on Windows.  We’ve <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=545234" rel="nofollow noopener">struggled ourselves</a> for our smooth scrolling feature to reliably determine when the user is using a discrete wheel vs. something with fine grained deltas.  It seems we have to rely on a heuristic.  But still, maybe better for the browser to have a heuristic that’s mostly right, then for every web developer to try to guess? /cc  <span class="mention">@bokan</span> <span class="mention">@garykac</span> <span class="mention">@teddink</span> <span class="mention">@jacobrossi</span></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1013_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">IvanSanchez</div>
          <div class="creation_date">2016-06-03</div>
          <div class="post_content">
<aside class="quote" data-post="10" data-topic="1138">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="//discourse.wicg.io/user_avatar/discourse.wicg.io/rickbyers/40/503_1.png" width="20"/> RickByers:</div>
<blockquote>
<p>you really want different behavior for discrete-wheel devices (one zoom level per tick) from devices with some sort of continuous zoom.</p>
</blockquote>
</aside>
<p>Yes - the idea is very aligned with <a href="https://github.com/w3c/uievents/issues/17" rel="nofollow noopener">adding <code>ticks</code> to <code>WheelEvent</code>s</a>. However, as s developer I wouldn’t know if the <code>tick</code> is due to a discrete-wheel device, or due to a threshold in a trackpad.</p>
<p>Also, I would like to know whether a <code>WheelEvent</code> is due to physical interaction on the device, or due to “inertia” scrolling after the user has lifted their fingers.</p>
<blockquote>
<p>But still, maybe better for the browser to have a heuristic that’s mostly right, then for every web developer to try to guess?</p>
</blockquote>
<p>Browsers have a much better chance at getting the heruistics right - I, as a web dev, would trust a proper implementation of <code>ticks</code> rather than the heruistics we use now.</p>
<p>So off the top of my head I’d suggest:</p>
<p><code>firesWheelEvents = true | false</code> (keeping the current nomenclature of <code>firesTouchEvents</code>)</p>
<p><code>firesWheelTicks = true | false</code>, the browser is sure enough about its heruistics/platform/etc to provide <code>ticks</code> in a consistent way; if <code>false</code>, web devs should rather rely on their own heruistics based on pixels/lines).</p>
<p><code>wheelSubTickResolution = true | false</code>, whether the device can scroll by an amount smaller than one tick (wheeled mice vs trackpads), <code>undefined</code> when <code>firesWheelEvents=false</code> or unknown.</p>
<p>I’m not sure if <code>InputDeviceCapabilities</code> would be the right place for handling the mismatch between wheel deltas between browsers. For heruistics, it’d be great to know how much pixel delta is expected for a ““normal”” tick - something to tell the 42 pixels from Firefox in linux apart from the 125 pixels on Edge.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1919_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">jacobrossi</div>
          <div class="creation_date">2016-06-03</div>
          <div class="post_content">
<p>Totally understand the value here, but this is going to be challenging to get right on Windows for sure.</p>
<p>For example, intertia from wheels/trackpads is often implemented by the device’s proprietary driver via just injecting additional wheel messages with decreasing deltas over a curve. So the OS nor browser actually know that these are synthetic inertia events rather than actual physical user interaction. A heuristic here would be challenging.</p>
<p>Ticks would also be challenging with mice that can switch (e.g. many mice have a toggle between detented wheeling and smooth wheeling). Some mice that are smooth scrolling wheels still inject discrete, non-high-res wheel events for compatibility purposes.</p>
<p>Then there are all the differences between classic trackpads and “Precision Touchpads” on Windows.</p>
<p>It’s a mess sadly and not one easily fixed given the complex device and proprietary driver ecosystem out there.</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>
