<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>[Proposal] Element Timing</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>
  
  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="66" alt="WICG" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">A partial archive of discourse.wicg.io as of Thursday February 08, 2024.</div>
    <h1 class="topic-title">[Proposal] Element Timing</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2709_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nicolas_Pena</div>
          <div class="creation_date">2018-07-06</div>
          <div class="post_content">
<p>The Element Timing API provides timing on when elements are displayed. This first proposal is restricted to  &lt;img&gt; elements to make it simpler:</p>
<aside class="onebox githubblob">
<header class="source">
<a href="https://github.com/npm1/Element-Timing/blob/master/README.md" rel="nofollow noopener" target="_blank">github.com</a>
</header>
<article class="onebox-body">
<h4><a href="https://github.com/npm1/Element-Timing/blob/master/README.md" rel="nofollow noopener" target="_blank">npm1/Element-Timing/blob/master/README.md</a></h4>
<pre><code class="lang-md"># Element Timing V1 Explainer

tdresser@, npm@

Last updated July 5, 2018

The **Element Timing** API enables monitoring when large or developer-specified image elements are displayed on screen.


### Objectives

1.  Inform developers when specific 'hero' elements are first displayed on the screen. To keep the first version of this API simpler and have an easier path towards standardization, we restrict to HTML 'img' elements. Web developers can better understand which are the critical images of their sites, so after annotating them the browser can provide timing information about those elements.
1.  Enable analytics providers to measure display time of key images, without explicit opt in from web developers. In many cases it's not feasible for developers to modify their HTML just to get better performance insights, so it's important to provide basic information even for websites that cannot annotate their elements.


### How do we register images for observation?

There are two ways an image can be registered for observation: via an HTML attribute and when the image takes a large portion of the viewport when it is first displayed.

#### Attributes
</code></pre>

  This file has been truncated. <a href="https://github.com/npm1/Element-Timing/blob/master/README.md" rel="nofollow noopener" target="_blank">show original</a>
</article>
<div class="onebox-metadata">
</div>
<div style="clear: both"></div>
</aside>

          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1137_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Garbee</div>
          <div class="creation_date">2018-07-07</div>
          <div class="post_content">
<p>What would this do that an Intersection Observer doesn’t allow for? You can use an Intersection Observer to know when a node is in the active viewport. And then do something based on that event. It sounds exactly like what your intended goal is, except far more widely applicable to web applications.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2709_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nicolas_Pena</div>
          <div class="creation_date">2018-07-09</div>
          <div class="post_content">
<p>The main reason this is preferred over Intersection Observer is because we want to avoid forcing developers to run Javascript very early in the page load. You’d need to run a script that registers the Intersection Observer very early on for it to work. This would not be required with Element Timing because the PerformanceObserver could be created with a buffered flag that provides values measured before its creation.</p>
<p>Also, IntersectionObserver wouldn’t be ergonomic for this use case: handling the question of when the element has loaded, wanting only the first update for the element, etc.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2709_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nicolas_Pena</div>
          <div class="creation_date">2019-02-21</div>
          <div class="post_content">
<p>We are still interested in moving forward with the proposal and have evolved it a bit.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2215_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">cvazac</div>
          <div class="creation_date">2019-02-22</div>
          <div class="post_content">
<p>As part of the origin trial, <a href="https://github.com/SOASTA/boomerang/" rel="nofollow noopener">we</a> prototyped a <a href="https://gist.github.com/nicjansma/84833e3a108d22e456a6eb7e6db7139b" rel="nofollow noopener">plugin</a> to collect the new Element Timing data. And we have a few ideas for features built on top of this data.</p>
<p>We anxiously await ET landing in Chrome by default!</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2709_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nicolas_Pena</div>
          <div class="creation_date">2019-02-25</div>
          <div class="post_content">
<p>Since there seems to be some support to this feature, I’d like to move the repo to WICG and continue incubating it from there. I’ll have a spec to accompany the explainer soon.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1710_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">yoavweiss</div>
          <div class="creation_date">2019-02-25</div>
          <div class="post_content">
<p>Thank you for incubating WICG! <img alt=":slight_smile:" class="emoji" src="//discourse.wicg.io/images/emoji/twitter/slight_smile.png?v=6" title=":slight_smile:"/> The repo has now moved and is at <a href="https://github.com/WICG/Element-Timing" rel="nofollow noopener">https://github.com/WICG/Element-Timing</a></p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>
