<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>[Proposal] EventTarget.prototype.getEventListeners()</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>
  
  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="66" alt="WICG" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">A partial archive of discourse.wicg.io as of Thursday February 08, 2024.</div>
    <h1 class="topic-title">[Proposal] EventTarget.prototype.getEventListeners()</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1843_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">leaverou</div>
          <div class="creation_date">2017-02-16</div>
          <div class="post_content">
<p><strong>Purpose:</strong> This would provide a way to get all event listeners added to an element via <code>addEventListener</code>.</p>
<p><strong>Signature:</strong> <code>element.getEventListeners([type])</code></p>
<p><strong>Returns:</strong> Array of objects. Each object contains properties for <code>type</code>, <code>callback</code>, <code>options</code> for the arguments that registered the corresponding event listener. Events registered via inline event handlers are not included.</p>
<p><strong>Use cases:</strong> This would enable removing events based on arbitrary criteria, instead of requiring a reference to the callback, which causes unnecessary couplings. Typically libraries deal with this by providing their own abstractions for adding events that track the listeners manually. However, this is fragile, as it means listeners not registered via the library cannot be retrieved or removed. Some libraries deal with this by hijacking <code>addEventListener</code> to keep track of listeners, but this is very intrusive for a library and it doesn’t help with any listeners registered before the library was included. Browsers already keep track of event listeners, so it should be relatively easy to expose them, and is on par with the Extensible Web Manifesto principle of exposing browser “magic” via JS APIs.</p>
<p>Edit: WHATWG proposal: <a href="https://github.com/whatwg/dom/issues/412" rel="nofollow noopener">https://github.com/whatwg/dom/issues/412</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1230_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">lydell</div>
          <div class="creation_date">2017-02-19</div>
          <div class="post_content">
<p>Another use case: <a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions" rel="nofollow noopener">WebExtensions</a>.</p>
<p>The <a href="https://github.com/akhodakivskiy/VimFx" rel="nofollow noopener">VimFx</a> extension uses a Firefox API called <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIEventListenerService#getListenerInfoFor()" rel="nofollow noopener">nsIEventListenerService.getListenerInfoFor</a>. <code>getEventListeners</code> sounds like a great replacement as VimFx transitions to become a WebExtension.</p>
<p>The <a href="https://github.com/philc/vimium" rel="nofollow noopener">Vimium</a> (Chrome/Web) extension has a <a href="https://github.com/philc/vimium/pull/1859" rel="nofollow noopener">pull request</a> open for hacking <code>addEventListener</code> to be able to keep track of which elements have click handlers.</p>
<p>Both of these extensions try to identify every clickable element on web pages, and let the user click those using the keyboard only.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">mkay581</div>
          <div class="creation_date">2017-02-27</div>
          <div class="post_content">
<p>Nice! I’ve ran into situations where this would be extremely helpful. Would be great if someone picked this up.</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>
